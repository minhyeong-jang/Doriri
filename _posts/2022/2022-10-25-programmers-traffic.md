---
layout: post
tags: [develop, study]
image: /covers/programmers.jpg
title: programmers - 추석트래픽
author: minhyeong.jang
date: 2022-10-25 20:52
---

## Level3 문제

이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. 초당 최대 처리량은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다.

## 해결방법

임의의 한 구간을 선택해서 1s안에 몇 개의 타임라인이 지나가는지 구하는 문제이다.  
임의라는게 가장 헷갈리는 부분인데, 단순하게 생각해보면 이미 종료시점에 맞춰서 데이터가 정렬되어서 내려온다.

즉, 데이터를 반복문 돌렸을 때 다음 데이터의 종료시점은 무조건 나보다 뒤에 있다. 그렇다면 시작 시간이 현재 데이터 구간 안에 다음 데이터가 포함되는 지를 확인하면 되고 그게 1s가 된다.

이게 설명을 하려니까 어려운데, 소스코드 내에서 설명하는 편이 편할 것 같다.

## 소스코드

- 시작, 종료, 작업시간을 구하는데 split으로 작성하기에는 코드가 길어져서 정규식으로 진행했다.
- 종료시간을 기준으로 반복문을 돌리며 그 다음 index의 데이터들의 시작시간을 확인한다. 이때, 포함해야하는 기준이 1000ms이기에 해당 값을 빼서 종료시간보다 이전이였는지 체크한다.
- 일치한다면 개수를 체크한다. 해당 방식으로 모든 반복문을 돌린다.

```js
function solution(lines) {
  let maxCount = 0;
  const workingTime = lines.map((item) => {
    const reg = item.match(/(\d{2})\:(\d{2})\:([\d\.]{6})\s(.*)s$/);
    const endTime = (reg[1] * 3600 + reg[2] * 60 + parseFloat(reg[3])) * 1000;
    const startTime = endTime - reg[4] * 1000 + 1;
    return [startTime, endTime];
  });

  workingTime.forEach((item, index) => {
    let count = 1;
    const [_, endTime] = item;
    for (let i = index + 1; i < workingTime.length; i++) {
      if (endTime > workingTime[i][0] - 1000) {
        count++;
      }
    }
    maxCount = Math.max(maxCount, count);
  });
  return maxCount;
}

solution(["2016-09-15 01:00:04.001 2.0s", "2016-09-15 01:00:07.000 2s"]);
solution([
  "2016-09-15 20:59:57.421 0.351s",
  "2016-09-15 20:59:58.233 1.181s",
  "2016-09-15 20:59:58.299 0.8s",
  "2016-09-15 20:59:58.688 1.041s",
  "2016-09-15 20:59:59.591 1.412s",
  "2016-09-15 21:00:00.464 1.466s",
  "2016-09-15 21:00:00.741 1.581s",
  "2016-09-15 21:00:00.748 2.31s",
  "2016-09-15 21:00:00.966 0.381s",
  "2016-09-15 21:00:02.066 2.62s",
]);
```

## 참고사항

처음 작업하면서 3, 18번 테스트가 실패했는데, 반복문 내에서 다음 데이터가 조건에 일치하지 않는 경우 break문을 사용했다. 생각해보니 다음 데이터의 시작시간이 해당 안되더라도 그 뒤의 데이터 로딩이 더 길어서 시작시간이 조건에 맞을 수도 있다. 그래서 해당 조건을 삭제했다.

이후 3번 테스트가 계속 실패했는데, 처음에는 parseFloat 사용하고 부동소수점을 날리는 방식으로 진행했었다. 해당 부분에서 오차가 발생했는지 1000을 곱해서 자연수로만 연산하니 정상적으로 통과했다.
